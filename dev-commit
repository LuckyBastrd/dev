#!/usr/bin/env bash

set -euo pipefail

# Configuration
readonly SCRIPT_NAME=$(basename "$0")
readonly AUTO_COMMIT_MSG="automated dev commit"
readonly STASH_MSG="Auto-stash before rebase"

# Colors for output
readonly COLOR_RESET='\033[0m'
readonly COLOR_BLUE='\033[0;34m'
readonly COLOR_GREEN='\033[0;32m'
readonly COLOR_YELLOW='\033[1;33m'
readonly COLOR_RED='\033[0;31m'

# Parse arguments
AUTO_YES=false
while [[ $# -gt 0 ]]; do
  case $1 in
    --yes|-y)
      AUTO_YES=true
      shift
      ;;
    --help|-h)
      echo "Usage: $SCRIPT_NAME [--yes|-y]"
      echo "  --yes, -y    Automatically push without confirmation"
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      exit 1
      ;;
  esac
done

# Utility functions
log_section() {
  echo ""
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
  echo "$1"
  echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
}

log_subsection() {
  echo ""
  echo "--------------------------------------------------"
  echo "$1"
  echo "--------------------------------------------------"
}

log_info() {
  echo "‚ÑπÔ∏è  $1"
}

log_success() {
  echo "‚úÖ $1"
}

log_warning() {
  echo "‚ö†Ô∏è  $1"
}

log_error() {
  echo "‚ùå $1" >&2
}

# Check if repository is in a rebase state
check_rebase_state() {
  local repo_path="$1"
  if [ -d "$repo_path/.git/rebase-apply" ] || [ -d "$repo_path/.git/rebase-merge" ]; then
    log_error "Unfinished rebase detected in $repo_path"
    log_info "Run 'git rebase --continue' after resolving conflicts."
    return 1
  fi
  return 0
}

# Check if there are any changes (staged, unstaged, or untracked)
has_changes() {
  ! git diff --quiet || ! git diff --cached --quiet || [ -n "$(git ls-files --others --exclude-standard)" ]
}

# Stash changes if present
stash_if_needed() {
  if ! git diff --quiet || ! git diff --cached --quiet; then
    log_info "Stashing local changes..."
    git stash push -m "$STASH_MSG"
    return 0
  fi
  return 1
}

# Reapply stashed changes
pop_stash() {
  log_info "Reapplying stashed changes..."
  if ! git stash pop; then
    log_warning "Failed to pop stash ‚Äî resolve manually."
    return 1
  fi
  return 0
}

# Perform rebase from origin
rebase_from_origin() {
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  
  log_info "Fetching from origin..."
  git fetch origin
  
  log_info "Rebasing from origin/$current_branch..."
  if ! git rebase "origin/$current_branch"; then
    log_error "Rebase failed ‚Äî resolve manually."
    return 1
  fi
  return 0
}

# Commit and optionally push changes
commit_and_push() {
  local repo_name="$1"
  
  log_info "Checking for changes..."
  if has_changes; then
    git add -A
    git commit -m "$AUTO_COMMIT_MSG"
    log_success "Committed changes in $repo_name"
    
    if $AUTO_YES; then
      log_info "Auto-pushing changes..."
      if git push; then
        log_success "Pushed changes in $repo_name"
      else
        log_error "Push failed for $repo_name"
        return 1
      fi
    else
      read -p "‚ùì Push & keep commit in $repo_name? (y/n): " -r confirm
      if [[ "$confirm" =~ ^[Yy]$ ]]; then
        log_info "Pushing changes..."
        if git push; then
          log_success "Pushed changes in $repo_name"
        else
          log_error "Push failed for $repo_name"
          return 1
        fi
      else
        log_warning "Skipping push. Resetting last commit..."
        git reset --soft HEAD~1
      fi
    fi
  else
    log_success "No changes to commit in $repo_name"
  fi
  return 0
}

# Process a single repository (submodule or root)
process_repo() {
  local repo_path="$1"
  local repo_name="$2"
  local original_dir
  original_dir=$(pwd)
  
  log_subsection "üì¶ Processing: $repo_name"
  
  cd "$repo_path" || {
    log_error "Failed to enter directory: $repo_path"
    return 1
  }
  
  local stashed=false
  local exit_code=0
  
  # Check for rebase state
  if ! check_rebase_state "$repo_path"; then
    exit_code=1
  else
    # Stash changes if needed
    if stash_if_needed; then
      stashed=true
    fi
    
    # Rebase from origin
    if ! rebase_from_origin; then
      exit_code=1
    else
      # Pop stash if we stashed earlier
      if $stashed; then
        pop_stash || exit_code=1
      fi
      
      # Commit and push changes
      if ! commit_and_push "$repo_name"; then
        exit_code=1
      fi
    fi
  fi
  
  cd "$original_dir" || exit 1
  return $exit_code
}

# Main execution
main() {
  echo "üß† Starting commit & push process for submodules and dev root repo..."
  
  # Process submodules
  log_section "üîÅ Step 1: Processing submodules..."
  
  local submodules
  submodules=$(git config --file .gitmodules --get-regexp path | awk '{ print $2 }')
  
  if [ -z "$submodules" ]; then
    log_info "No submodules found"
  else
    for submodule in $submodules; do
      if ! process_repo "$submodule" "$submodule"; then
        log_error "Failed to process submodule: $submodule"
        exit 1
      fi
    done
  fi
  
  # Process root repository
  log_section "üß† Step 2: Processing root repo: dev/"
  
  local repo_root
  repo_root=$(git rev-parse --show-toplevel)
  
  if ! process_repo "$repo_root" "dev/"; then
    log_error "Failed to process root repository"
    exit 1
  fi
  
  echo ""
  echo "üéâ All done!"
}

# Run main function
main "$@"
